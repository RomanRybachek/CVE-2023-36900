#ifndef UNICODE
#define UNICODE
#endif

#include <windows.h>
#include <wchar.h>
#include <iostream>
#include <clfsw32.h>
#include <Clfsmgmtw32.h>

#pragma comment(lib, "Clfsw32.lib")

#define ARRAY_LENGTH 5
#define RECORD_LENGTH 20

void ErrorExit(const char* id)
{
    DWORD errNum = GetLastError();
    std::cerr << "Encountered unexpected error from " << id << ": " << std::endl
        << errNum << std::endl;
    exit(errNum);
}

HANDLE g_logHndl;
void* g_marsh_context;

void create_log(int argc, wchar_t* argv[]) {

	if (argc < 2) {
		std::cout << "An absoulte path to log is needed";
		exit(1);
	}

	g_logHndl = 0;
	g_marsh_context = NULL;

	std::wstring path(L"LOG:");
	path += argv[1];

	g_logHndl = CreateLogFile(
		path.c_str(),
		GENERIC_READ | GENERIC_WRITE | DELETE,
		FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
		NULL,
		OPEN_ALWAYS,
		NULL);

	if (g_logHndl == INVALID_HANDLE_VALUE) {
		ErrorExit("Creating/opening log file error.");
	}
	else
	{
		std::wcout << L"Log " << path << L" is created/opened." << std::endl;
	}
}

int wmain(int argc, wchar_t* argv[])
{
	create_log(argc, argv);

	CLFS_WRITE_ENTRY* w_entry_array = new CLFS_WRITE_ENTRY[ARRAY_LENGTH];
	for (SIZE_T i = 0; i < ARRAY_LENGTH; i++)
	{
		w_entry_array[i].Buffer = new char[RECORD_LENGTH];
		w_entry_array[i].ByteLength = RECORD_LENGTH;
		memset(w_entry_array[i].Buffer, 0, RECORD_LENGTH);
		sprintf_s((char*)w_entry_array[i].Buffer, RECORD_LENGTH, "record%lld", i);
	}
    return 0;
}
