import zlib
import pwnlib.util.packing as pk
import sys

LOG_BLOCK_HDR_SIZE = 0x6c
RG_BLOCKS_START = 0xc0
RG_BLOCKS_END = 0x14f

class RgBlock():
    def __init__(self, index):
        self.index = index
        self.start = 0
        self.size = 24

        self.rgBlocksArray = BLF_BUF[RG_BLOCKS_START:RG_BLOCKS_END]
        self.block = self.rgBlocksArray[index  * self.size : index * self.size  + self.size]

        self.pbImage = pk.u64(self.block[:8])
        self.cbImage = pk.u32(self.block[8:12])
        self.cbOffset = pk.u32(self.block[12:16])
        self.eBlockType = pk.u32(self.block[16:20])

    def GetBytes(self):
        return pk.p64(self.pbImage) + pk.p32(self.cbImage)+ pk.p32(self.cbOffset)+ pk.p32(self.eBlockType)

    def update_blf(self, update_crc32_too=False):
        global BLF_BUF
        buf_before = BLF_BUF[:RG_BLOCKS_START + self.index * self.size]
        buf_after = BLF_BUF[RG_BLOCKS_START + self.index * self.size + self.size:]
        BLF_BUF = buf_before + self.GetBytes() + buf_after
        if update_crc32_too == True:
            block_0 = Block(0)
            block_0.update_crc32()

class Block:
    def __init__(self, index) -> None:
        global BLF_BUF
        self.index = index
        self.rgBlock = RgBlock(index)
        self.start = self.rgBlock.cbOffset
        self.size_from_rgBlock = self.rgBlock.cbImage
        self.log_block_hdr = BLF_BUF[self.start : self.start+LOG_BLOCK_HDR_SIZE]
        self.sector_count = pk.u16(self.log_block_hdr[4:6])
        self.size_from_loghdr = self.sector_count << 9
        self.end = self.start + self.size_from_rgBlock
        self.block = BLF_BUF[self.start:self.end]
        self.size = self.end - self.start

    def get_rgBlock(self, block_index): #get rgBlock[index] from control record
        rgBlocksArray = BLF_BUF[0xc0:0x14f]
        block_size = 24
        rgBlock = rgBlocksArray[block_index  * block_size : block_index * block_size  + block_size]
        return rgBlock
        
    def get_offset_block(self, block):
        value = block[4 * 3 : 4 * 3 + 4]
        return pk.u32(value)

    def update_crc32(self):
        part_before_checksum = self.block[:0xc]
        part_after_checksum = self.block[0x10:]
        buf_with_zeroed_checksum = part_before_checksum + pk.p32(0) + part_after_checksum
        crc32 = zlib.crc32(buf_with_zeroed_checksum)
        self.block = part_before_checksum + pk.p32(crc32) + part_after_checksum
        global BLF_BUF
        part_before_block = BLF_BUF[:self.start]
        part_after_block = BLF_BUF[self.end:]
        BLF_BUF = part_before_block + self.block + part_after_block
        print("CRC32 of block[", self.index, "]:", hex(crc32))

def change_size_of_block(index):
    block = Block(index)


def create_new_file():
    global NEW_NAME
    fd_w = open(NEW_NAME, "wb")
    fd_w.write(BLF_BUF)
    print(NEW_NAME, " is created!")
    fd_w.close()

if len(sys.argv) < 2:
    print("\nUsage: python3 update_crc32.py path_to_blf\n")
    exit(1)

blf_path = sys.argv[1]
if blf_path.find(".blf") == -1:
    print("\nFile must have .blf extension.\n")
    exit(1)

fd = open(blf_path, "rb")
BLF_BUF = fd.read()
fd.close()
NEW_NAME = blf_path.replace(".blf", "_updated.blf")

block0 = Block(0)
block0.update_crc32()
block5 = Block(5)
block5.update_crc32()
create_new_file