# Walkthrough
About this vulnerability: https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-36900.
### Basic analysis of the patch:
The function at address 0x1C005107C has been patched:<br/>
<img src="https://github.com/RomanRybachek/CVE-2023-36900/blob/main/walkthrough/resources/graph_before_n_after.png" alt="drawing" width="400"/><br/>
This cmp has been added:<br/>
<img src="https://github.com/RomanRybachek/CVE-2023-36900/blob/main/walkthrough/resources/cmp.png" alt="drawing" width = "600"><br/>
After the cmp instruction, the small block of code is executed and function goes to return: <br/>
<img src="https://github.com/RomanRybachek/CVE-2023-36900/blob/main/walkthrough/resources/cmp_at_graph.png" alt="drawing" width = "400"><br/>
The small block of code in disassembler: <br/>
<img src="https://github.com/RomanRybachek/CVE-2023-36900/blob/main/walkthrough/resources/little_block_in_disasm.png" alt="drawing" width = "600"><br/>
And in decompiler: <br/>
<img src="https://github.com/RomanRybachek/CVE-2023-36900/blob/main/walkthrough/resources/little_block_in_decompiler.png" alt="drawing" width = "600"><br/>
This code is typical for drivers. It is [WPP tracing](https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/wpp-software-tracing). 
So it is not interesting to us. But we should pay attention to the return code. It is 0xC0000095 that means [STATUS_INTEGER_OVERFLOW](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55).
That's a good hint for us. <br/><br/>
Pseudocode of the patched function without details:<br/>
```C++
MACRO_STATUS CClfsBaseFilePersisted::ExtendMetadataBlockDescriptor(
        CClfsBaseFilePersisted *this,
        CLFS_METADATA_BLOCK_TYPE *iFlushBlock,
        unsigned int num_of_extendSectors_div_2)
{
  // size_of_extend_sectors_div2 = num_of_extendSectors_div_2 * 0x200u
  if ( RtlULongMult(num_of_extendSectors_div_2, 0x200u, &size_of_extend_sectors_div2) < 0 )
    return 0xC01A000Di64;
  //size_of_flushBlockSectors_and_extendSecorsDiv2 = size_of_extend_sectors_div2 * this->CClfsBaseFile.m_rgBlocks[*iFlushBlock].cbImage
  sum_ntstatus = RtlULongAdd(
                   size_of_extend_sectors_div2,
                   this->CClfsBaseFile.m_rgBlocks[*iFlushBlock].cbImage,
                   &size_of_flushBlockSectors_and_extendSecorsDiv2);
  if ( sum_ntstatus < 0 )
    return 0xC01A000Di64;

  m_cbRawSectorSize = this->CClfsBaseFile.m_cbRawSectorSize;// always 512 (0x200)

  // Round the number up
  if ( m_cbRawSectorSize )
    rounded_sum = -m_cbRawSectorSize & (m_cbRawSectorSize + size_of_flushBlockSectors_and_extendSecorsDiv2 - 1);
  else
    rounded_sum = 0;

  // Cmp that was added by the patch
  if ( rounded_sum >= size_of_flushBlockSectors_and_extendSecorsDiv2 )
  {/* main body of the funcion */}
  else{
    /* something with WPP */
    return STATUS_INTEGER_OVERFLOW;
  }
...}
```
The vulnerability is that the variable `rounded_sum` may be less than `size_of_flushBlockSectors_and_extendSecorsDiv2`.
If `size_of_flushBlockSectors_and_extendSecorsDiv2` will be great than `0xffffffff - 0x200 + 1` we'll end up in the 'else' block and leave
the function with STATUS_INTEGER_OVERFLOW.
But in the unpatched version, we will continue execution.<br/> <br/>
The variable `size_of_flushBlockSectors_and_extendSecorsDiv2` depends on the value of `size_of_extend_sectors_div2` and the value of `iFlushBlock`. Both of them are function parameters. So, we need to manipulate these parameters so that we end up in the 'else' block.
