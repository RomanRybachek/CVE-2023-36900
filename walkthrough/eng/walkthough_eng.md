# Writeup
About this vulnerability: https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-36900.<br/>
- [Basic analysis of the patch](basic-analysis-of-the-patch)
- [Analysis of the vulnerable function](analysis-of-the-vulnerable-function)
### Basic analysis of the patch
The function at address 0x1C005107C has been patched:<br/>
<img src="https://github.com/RomanRybachek/CVE-2023-36900/blob/main/walkthrough/resources/graph_before_n_after.png" alt="drawing" width="400"/><br/>
This cmp has been added:<br/>
<img src="https://github.com/RomanRybachek/CVE-2023-36900/blob/main/walkthrough/resources/cmp.png" alt="drawing" width = "600"><br/>
After the cmp instruction, the small block of code is executed and function goes to return: <br/>
<img src="https://github.com/RomanRybachek/CVE-2023-36900/blob/main/walkthrough/resources/cmp_at_graph.png" alt="drawing" width = "400"><br/>
The small block of code in disassembler: <br/>
<img src="https://github.com/RomanRybachek/CVE-2023-36900/blob/main/walkthrough/resources/little_block_in_disasm.png" alt="drawing" width = "600"><br/>
And in decompiler: <br/>
<img src="https://github.com/RomanRybachek/CVE-2023-36900/blob/main/walkthrough/resources/little_block_in_decompiler.png" alt="drawing" width = "600"><br/>
This code is typical for drivers. It is [WPP tracing](https://learn.microsoft.com/en-us/windows-hardware/drivers/devtest/wpp-software-tracing). 
So it is not interesting to us. But we should pay attention to the return code. It is 0xC0000095 that means [STATUS_INTEGER_OVERFLOW](https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-erref/596a1078-e883-4972-9bbc-49e60bebca55).
That's a good hint for us. <br/><br/>
Pseudocode of the patched function without details:<br/>
```C++
MACRO_STATUS CClfsBaseFilePersisted::ExtendMetadataBlockDescriptor(
        CClfsBaseFilePersisted *this,
        CLFS_METADATA_BLOCK_TYPE *iFlushBlock,
        unsigned int num_of_extendSectors_div_2)
{
  // size_of_extend_sectors_div2 = num_of_extendSectors_div_2 * 0x200u
  if ( RtlULongMult(num_of_extendSectors_div_2, 0x200u, &size_of_extend_sectors_div2) < 0 )
    return 0xC01A000Di64;
  //size_of_flushBlockSectors_and_extendSecorsDiv2 = size_of_extend_sectors_div2 * this->CClfsBaseFile.m_rgBlocks[*iFlushBlock].cbImage
  sum_ntstatus = RtlULongAdd(
                   size_of_extend_sectors_div2,
                   this->CClfsBaseFile.m_rgBlocks[*iFlushBlock].cbImage,
                   &size_of_flushBlockSectors_and_extendSecorsDiv2);
  if ( sum_ntstatus < 0 )
    return 0xC01A000Di64;

  m_cbRawSectorSize = this->CClfsBaseFile.m_cbRawSectorSize;// always 512 (0x200)

  // Round the number up
  if ( m_cbRawSectorSize )
    rounded_sum = -m_cbRawSectorSize & (m_cbRawSectorSize + size_of_flushBlockSectors_and_extendSecorsDiv2 - 1);
  else
    rounded_sum = 0;

  // Cmp that was added by the patch
  if ( rounded_sum >= size_of_flushBlockSectors_and_extendSecorsDiv2 )
  {/* main body of the funcion */}
  else{
    /* something with WPP */
    return STATUS_INTEGER_OVERFLOW;
  }
...}
```
The vulnerability is that the variable `rounded_sum` may be less than `size_of_flushBlockSectors_and_extendSecorsDiv2`.
If `size_of_flushBlockSectors_and_extendSecorsDiv2` will be great than `0xffffffff - 0x200 + 1` we'll end up in the 'else' block and leave
the function with STATUS_INTEGER_OVERFLOW.
But in the unpatched version, we will continue execution and get [BSOD](https://en.wikipedia.org/wiki/Blue_screen_of_death).<br/> <br/>
The variable `size_of_flushBlockSectors_and_extendSecorsDiv2` depends on the value of `size_of_extend_sectors_div2` and the value of `iFlushBlock`. Both of them are function parameters. So, we need to manipulate these parameters so that we end up in the 'else' block.
### Analysis of the vulnerable function
This function is called only from two other functions: 
- CClfsBaseFilePersisted::ProcessCurrentBlockForExtend
- CClfsBaseFilePersisted::ExtendMetadataBlock</br>

The arguments submitted to the function are identical in both cases:</br>
```
status = CClfsBaseFilePersisted::ExtendMetadataBlockDescriptor(
             this,
             control_record->iFlushBlock,
             control_record->cExtendSectors / 2);
```
That is control_record in this call?</br></br>
The [clfs.sys](https://en.wikipedia.org/wiki/Common_Log_File_System) driver keeps data about it's logs in files with .blf extension. When you call `CreateLogFile` WinAPI function, clfs.sys creates a new log file. This file contains an area called control record. The control record contains information about the layout of the blf file.</br></br>
<img src="https://github.com/RomanRybachek/CVE-2023-36900/blob/main/git_resources/ctrl_record_example.png" alt="drawing" width = "1000"><br/><br/>
Here we see the fields that are passed as arguments to the vulnerable function. How this fields are used in the function? The field `cExtendSectors` is divided by two when submitted to the function and multiplied by 0x200 in the function itself:<br/>
```
RtlULongMult(num_of_extendSectors_div_2, 0x200u, &size_of_extend_sectors_div2)
```
The field `iFlushBlock` is used as an index in `rgBlocks` array that reside in control record too, but in the code below, it is already loaded into the `CClfsBaseFile` structure, that is an in-memory representation of the blf file.<br/>
```
RtlULongAdd(size_of_extend_sectors_div2,
            this->CClfsBaseFile.m_rgBlocks[*iFlushBlock].cbImage,
            &size_of_flushBlockSectors_and_extendSecorsDiv2);
```
A blf file consists of six blocks, each with its own purpose. The `rgBlocks` array stores the location and size of the blocks. The `cbImage` field sets the size of the block in the file. <br/><br/>
<img src="https://github.com/RomanRybachek/CVE-2023-36900/blob/main/git_resources/rgBlocks_example.png" alt="drawing" width = "1000"><br/><br/>
So, in the code above we multiply size of the block that has been determine by `iFlushBlock` field and value that we get from operations with `cExtendSectors`.<br/>
Then, the obtained value is rounded up to the disk sector boundary (512 bytes):<br/>
```
  m_cbRawSectorSize = this->CClfsBaseFile.m_cbRawSectorSize;// always 512 (0x200)

  // Round the number up
  if ( m_cbRawSectorSize )
    rounded_sum = -m_cbRawSectorSize & (m_cbRawSectorSize + size_of_flushBlockSectors_and_extendSecorsDiv2 - 1);
  else
    rounded_sum = 0;
```
And if we run unpatched version of clfs.sys, the rounded up value will be passed to `ExAllocatePoolWithTag` function, what will allocate kernel memory. Then from block with index `iFlushBlock` into the new memory will be copied `rgBlock[iFlushBlock].cbImage` number of bytes. 
```
allocated_mem = ExAllocatePoolWithTag(PagedPoolCacheAligned, rounded_up_size, 'sflC');
memmove(allocated_mem, pbImage, cbImage);
```
But if value of `size_of_flushBlockSectors_and_extendSecorsDiv2` is `0xfffffe01`, it will be rounded up to 0. And 0 will be passed to ExAllocatePoolWithTag. Then ExAllocatePoolWithTag will allocate number of bytes less than `rgBlock[iFlushBlock].cbImage`, because the minimum value of `rgBlock[iFlushBlock].cbImage` is 0x200. So, chunks that lie after the allocated chunk will be corrupted. But that's not all. Then the following code will be called:<br/>
```
difference = rounded_up_size - cbImage;
memset(allocated_mem + rgBlocks[iFlushBlock].cbImage, 0, difference);
```
It means that `0 - 0x200 = 0xfffffe00` additional kernel memory will be corrupted.
